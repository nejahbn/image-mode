= Creación de una máquina virtual con bootc containers
include::_attributes.adoc[]

[#descripcion]
== Descripción

En este caso práctico, crearemos una máquina virtual (VM) a partir de una imágen de contenedor.

Veremos cómo bootc aprovecha la tecnología de contenedores existente para:

* Crear al aplicación en términos de su contenedor en tiempo de creación - el sistema no se cambia una vez desplegado.
* Acceder automáticamente al registro de imágenes del contenedor desplegado para automáticamente actualizar el sistema.
* Revertir el último cambio.

[#crear-images]
== Creación de la primera imagen

La definición de un contenedor es prácticamente igual que la de un contenedor tradicional, lo que cambia es la cláusula `+FROM+`.

[.lines_7]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
FROM registry.redhat.io/rhel9/rhel-bootc:9.4
----

En nuestro ejemplo simplemente crearemos un contenedor que instala y configura un servidor apache para servir contenido mediante el protocolo HTTPS.

Bootc viene instalado en esas imágenes junto con un temporizador que periódicamente comprueba si existen actualizaciones y aplicarlas.

Para nuestro caso práctico vamos a crear un sistema con el temporizador comprobando si existen actualizaciones cada 30 segundos. Para esto sobreescribimos
el temporizador en el momento de la creación de la imagen. Usamos la Containerfile:

[.lines_7]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
FROM registry.redhat.io/rhel9/rhel-bootc:9.4
RUN /usr/bin/dnf -y install firewalld httpd php mod_ssl langpacks-es && /usr/bin/rm -f /etc/httpd/conf.d/welcome.conf && /usr/bin/systemctl enable httpd
COPY bootc-fetch-apply-updates.timer /lib/systemd/system/
COPY motd /etc/motd.d/
COPY hostname /etc/
COPY index.php /var/www/html
COPY httpd.key /etc/pki/tls/private/
COPY httpd.crt /etc/pki/tls/certs/
COPY cacert.pem /etc/pki/tls/certs/
COPY ssl.conf /etc/httpd/conf.d/
COPY public.xml /etc/firewalld/zones/
COPY registries.conf /etc/containers/
EXPOSE 443
CMD [ "/sbin/init" ]
----

[IMPORTANT]
=====
Como hemos comentado **bootc containers** se encuentra en Technology Preview y todavía hay opciones de configuración que se están implementando. Por ese motivo hemos tenido que recurrir a:

[.lines_7]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
RUN /usr/bin/dnf -y install firewalld httpd php mod_ssl langpacks-es && /usr/bin/rm -f /etc/httpd/conf.d/welcome.conf && /usr/bin/systemctl enable httpd
----
=====

[NOTE]
=====
El timer de systemd que se encarga de comprobar si hay actualizaciones:

[.lines_7]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
$ cat bootc-fetch-apply-updates.timer
[Unit]
Description=Apply bootc updates
Documentation=man:bootc(8)
ConditionPathExists=/run/ostree-booted

[Timer]
OnBootSec=30seconds
# This time is relatively arbitrary and obviously expected to be overridden/changed
OnUnitActiveSec=30seconds
OnUnitInactiveSec=30seconds
# When deploying a large number of systems, it may be beneficial to increase this value to help with load on the registry.
RandomizedDelaySec=5seconds

[Install]
WantedBy=timers.target
$
----
=====

[TIP]
=====
Abrimos una terminal y nos conectamos por ssh con el usuario **demouser** al host **imagemode** y creamos el contedor utilizando podman:

[.lines_7]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
[imagemode@workstation ~]$ ssh demouser@imagemode
[demouser@imagemode ~]$ sudo su -
[root@imagemode ~]# cd image-mode
[root@imagemode ~]# cat create-container.sh
#!/bin/bash

podman build -f Containerfile.rhel9.4 -t rhel-bootc-vm:latest .

if [ $? -ne 0 ]
then
  echo "ERROR AL CONSTRUIR LA IMAGEN"
  exit 1
fi

podman tag localhost/rhel-bootc-vm:latest registry.lab.melmac.univ:5000/rhel-bootc-vm:latest

if [ $? -ne 0 ]
then
  echo "ERROR TAGEAR LA IMAGEN"
  exit 1
fi

podman push registry.lab.melmac.univ:5000/rhel-bootc-vm:latest

if [ $? -ne 0 ]
then
  echo "ERROR TAGEAR AL HACER PUSH"
  exit 1
fi
[root@imagemode ~]# bash create-container.sh
...
[root@imagemode ~]# podman images
REPOSITORY                                    TAG         IMAGE ID       CREATED           SIZE
localhost/rhel-bootc-vm                       latest       cc3e1af1b6a6  2 minutes ago     1.75 GB
...
[root@imagemode ~]# 
----
=====

En caso de bootable containers, no vamos a ejecutar esas imágenes sobre sistemas existentes sino vamos a crear sistemas con esos contenedores ya instalados.

Podemos crear sistemas de varias maneras: con imágenes para máquinas virtuales o también creando DVDs (ISO) que podemos utilizar para automáticamente instalar
un servidor baremetal con https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/9/html/automatically_installing_rhel/automated-installation-workflow_rhel-installer#automated-installation-workflow_rhel-installer[kickstart].

Aquí vamos a utilizar https://github.com/osbuild/bootc-image-builder[bootc-image-builder] para crear una VM de tipo KVM para ejecutarla en Linux utilizando https://libvirt.org[libvirt].

El bootc-image-builder está diseñado para ejecutarse desde un contenedor. Creamos un archivo `+config.toml+` para configurar un usuario y usamos podman para ejecutar la aplicación con nuestro container. Mas información en https://github.com/osbuild/bootc-image-builder[bootc-image-builder].

[TIP]
=====
[.lines_7]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
[root@imagemode ~]#  mkdir output
image-mode # cat config.toml
[[blueprint.customizations.user]]
name = "demouser"
password = "redhat"
key = "ssh-rsa ...."
groups = ["wheel"]

[root@imagemode image-mode]#  cat creating-vm.sh
#!/bin/bash

/usr/bin/podman run --rm -it --privileged --pull=newer --security-opt label=type:unconfined_t \
           -v $(pwd)/config.toml:/config.toml:ro -v $(pwd)/output:/output -v /var/lib/containers/storage:/var/lib/containers/storage \
           registry.redhat.io/rhel9/bootc-image-builder:latest \
           --type qcow2 --local registry.lab.melmac.univ:5000/rhel-bootc-vm:latest

if [ $? -ne 0 ]
then
  echo "Ocurrio un error creando la VM"
  exit 1
fi

/usr/bin/qemu-img convert -f qcow2 -O qcow2 -o lazy_refcounts=on $(pwd)/output/qcow2/disk.qcow2 /imagemode/image-mode-test.qcow2
[root@imagemode image-mode]# bash creating-vm.sh
...
[root@imagemode image-mode]#
----
=====

Cuando termine la ejecución de este script se habrá creado el disco de la máquina virtual y quedará dentro del directorio **output**. El script se encarga de copiar dicho disco a una unidad compartida para poder ejecutar la máquina virtual.

[TIP]
=====
Utilizando los comandos **cd** y **ls** puedes navegar por el directorio output para ver que se ha generado.
=====

En el portátil ya se encuentra creada una máquina virtual para ejecutar la máquina que hemos creado. El script anterior al copiar el disco creado a la carpeta compartida ha sobreescrito el disco existente y al arrancar la máquina virtual arrancará con el disco que hemos creado.

[TIP]
=====
Para arrancar la máquina virtual con el disco creado en el entorno gráfico del portátil vamos al launcher situado abajo y pinchamos en **Launch VM**:

image::launchvm.png[]

Una vez arrancada la máquina virtual:

image::vm.png[]
=====

Ahora podemos conectarnos a la máquina virtual que hemos creado y explorar.

[TIP]
=====
Tenemos dos formas de conectarnos, nos podemos conectar por ssh utilizando las credenciales definidas en el fichero **config.toml**:

[.lines_7]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
[root@imagemode image-mode]# ssh demouser@imagemodetest
[demouser@imagemodetest ~]$ 
----

Como en el fichero de configuración **config.toml** hemos incluido la clave pública no nos pedirá contraseña.

La otra forma de conectarnos es a través de la consola que hemos abierto con **Launch VM**. En este caso si nos pedirá constraseña. El usuario y la contraseña los tenemos en el fichero **config.toml**.
=====

[#update-rollback]
== Actualización y rollback

`+bootc+` es el comando que maneja los contenedores dentro de la VM. Viene con un temporizador que regularmente activa un servicio de systemd.
Ese servicio, si detecta que una nueva imagen está disponible, la descarga y reinicia el sistema para aplicarla.

Después de hacer log-in en la máquina comprobamos que el temporizador está activo:

[.lines_7]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
# sudo systemctl status bootc-fetch-apply-updates.timer
----

En lo que sigue, vamos a crear una nueva imagen y subirla al registro. Eso hará que el sistema se autoactualice. Observaremos en una consola el estado del servicio:

[.lines_7]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
# sudo journalctl -f -u bootc-fetch-apply-updates
Oct 01 16:05:54 localhost.localdomain systemd[1]: Starting Apply bootc updates...
Oct 01 16:05:54 localhost.localdomain bootc[1179]: Fetching ostree-unverified-registry:<registry>/demo:latest
Oct 01 16:05:54 localhost.localdomain bootc[1179]: No changes in <registry>/demo:latest => sha256:40106b8d8e453901b78398c819a6b95f4d7b55a28b8783d8e19e276197f2f814
Oct 01 16:05:54 localhost.localdomain bootc[1179]: No update available.
Oct 01 16:05:54 localhost.localdomain systemd[1]: bootc-fetch-apply-updates.service: Deactivated successfully.
Oct 01 16:05:54 localhost.localdomain systemd[1]: Finished Apply bootc updates.
----

En otra consola, cambiamos la Containerfile

[.lines_7]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
FROM quay.io/centos-bootc/centos-bootc:stream9
COPY bootc-fetch-apply-updates.timer /lib/systemd/system/
RUN echo v2 > /version
----

identificando esta nueva version en el archivo `+/version+`.

Seguimos los mismos pasos como en <<crear-images>>.

Veremos, cómo el servicio `+bootc-fetch-apply-updates+` encuentra la actualización, descarga los datos y reinicia el sistema.

[.lines_7]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
Oct 01 16:07:29 localhost.localdomain systemd[1]: Starting Apply bootc updates...
Oct 01 16:07:29 localhost.localdomain bootc[1206]: Fetching ostree-unverified-registry:<registry>/demo:latest
Oct 01 16:07:30 localhost.localdomain bootc[1206]: layers already present: 70; layers needed: 1 (141 bytes)
Oct 01 16:07:30 localhost.localdomain bootc[1206]: layers already present: 70; layers needed: 1 (141 bytes)
----

Después del reinicio, hacemos login y comprobamos que efectivamente, el sistema ha sido actualizado.

[.lines_7]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
$ sudo cat /version
v2
----

`+bootc+` si encontramos problemas con esta actualización podemos revertirla sin problema. Manualmente lo conseguimos ejecutando

[.lines_7]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
$ sudo bootc rollback
----

El sistema reiniciará y veremos que nos encontramos en la versión previa:

[.lines_7]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
$ sudo cat /version
v1
----

Si queremos evitar que el sistema se auto-actualice de nuevo a la versión errónea, debemos deshabilitar el temporizador

[.lines_7]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
$ sudo systemctl disable --now bootc-fetch-apply-updates.timer
----

Como hemos visto, `+bootc+` integra bien con herramientas existentes de contenedores. Esto significa que también disponemos de https://github.com/fedora-iot/greenboot[greenboot]
para que revertir automáticamente un sistema que no inicie bien después de una actualización.
