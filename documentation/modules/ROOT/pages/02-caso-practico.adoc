= Creación de una máquina virtual con bootc containers
include::_attributes.adoc[]

[#descripcion]
== Descriptción

En este caso práctico, crearemos una máquina virtual (VM) a partir de una imágen de contenedor.

Veremos cómo bootc aprovecha la tecnología de contenedores existente para:

* Crear al aplicación en términos de su contenedor en tiempo de creación - el sistema no se cambia una vez desplegado.
* Acceder automáticamente al registro de imágenes del contenedor desplegado para automáticamente actualizar el sistema.
* Revertir el último cambio.

[#crear-images]
== Creación de la primera imagen

La definición de un contenedor es prácticamente igual que la de un contenedor tradicional, lo que cambia es la cláusula `+FROM+`.

[.lines_7]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
FROM registry.redhat.io/rhel9/rhel-bootc:9.4
----

En nuestro ejemplo simplemente crearemos un contenedor que instala y configura un servidor apache para servir contenido mediante el protocolo HTTPS.

Bootc viene instalado en esas imágenes junto con un temporizador que periódicamente comprueba si existen actualizaciones y aplicarlas.

Para nuestro caso práctico vamos a crear un sistema con el temporizador comprobando si existen actualizaciones cada 30 segundos. Para esto sobreescribimos
el temporizador en el momento de la creación de la imagen. Usamos la Containerfile:

[.lines_7]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
FROM registry.redhat.io/rhel9/rhel-bootc:9.4
RUN /usr/bin/dnf -y install firewalld httpd php mod_ssl langpacks-es && /usr/bin/rm -f /etc/httpd/conf.d/welcome.conf && /usr/bin/systemctl enable httpd
COPY bootc-fetch-apply-updates.timer /lib/systemd/system/
COPY motd /etc/motd.d/
COPY index.php /var/www/html
COPY httpd.key /etc/pki/tls/private/
COPY httpd.crt /etc/pki/tls/certs/
COPY cacert.pem /etc/pki/tls/certs/
COPY ssl.conf /etc/httpd/conf.d/
COPY public.xml /etc/firewalld/zones/
EXPOSE 443
CMD [ "/sbin/init" ]
----

[NOTE]
=====
[.lines_7]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
$ cat bootc-fetch-apply-updates.timer
[Unit]
Description=Apply bootc updates
Documentation=man:bootc(8)
ConditionPathExists=/run/ostree-booted

[Timer]
OnBootSec=30seconds
# This time is relatively arbitrary and obviously expected to be overridden/changed
OnUnitActiveSec=30seconds
OnUnitInactiveSec=30seconds
# When deploying a large number of systems, it may be beneficial to increase this value to help with load on the registry.
RandomizedDelaySec=5seconds

[Install]
WantedBy=timers.target
$
----
=====

[TIP]
=====
Abrimos una terminal y nos conectamos por ssh con el usuario **demouser** al host **imagemode** y creamos el contedor utilizando podman:

[.lines_7]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
[imagemode@workstation ~]$ ssh demouser@imagemode
[demouser@imagemode ~]$ sudo su -
[root@imagemode ~]# cd image-mode
[root@imagemode ~]#  podman build -f Containerfile.rhel9.4 -t rhel-bootc-vm:latest .
...
[root@imagemode ~]# podman images
REPOSITORY                                    TAG         IMAGE ID       CREATED           SIZE
localhost/rhel-bootc-vm                       latest       cc3e1af1b6a6  2 minutes ago     1.75 GB
...
[root@imagemode ~]# 
----
=====

En caso de bootable containers, no vamos a ejecutar esas imágenes sobre sistemas existentes sino vamos a crear sistemas con esos contenedores ya instalados.

Podemos crear sistemas de varias maneras: con imágenes para máquinas virtuales o también creando DVDs (ISO) que podemos utilizar para automáticamente instalar
un servidor baremetal con https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/9/html/automatically_installing_rhel/automated-installation-workflow_rhel-installer#automated-installation-workflow_rhel-installer[kickstart].

Aquí vamos a utilizar https://github.com/osbuild/bootc-image-builder[bootc-image-builder] para crear una VM de tipo KVM para ejecutarla en Linux utilizando https://libvirt.org[libvirt].

El bootc-image-builder está diseñado para ejecutarse desde un contenedor. Creamos un archivo `+config.toml+` para configurar un usuario y usamos podman para ejecutar la aplicación con nuestro container. Mas información en https://github.com/osbuild/bootc-image-builder[bootc-image-builder].

[TIP]
=====
[.lines_7]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
[root@imagemode ~]#  mkdir output
image-mode # cat config.toml
[[blueprint.customizations.user]]
name = "demouser"
password = "redhat"
key = "ssh-rsa ...."
groups = ["wheel"]

[root@imagemode image-mode]#  cat creating-vm.sh
#!/bin/bash

podman run --rm -it --privileged --pull=newer --security-opt label=type:unconfined_t \
           -v $(pwd)/config.toml:/config.toml:ro -v $(pwd)/output:/output \
           -v /var/lib/containers/storage:/var/lib/containers/storage \
           registry.redhat.io/rhel9/bootc-image-builder:latest \
           --type qcow2 --local registry.melmac.univ:5000/rhel-bootc-vm:latest
[root@imagemode image-mode]# bash creating-vm.sh
...
[root@imagemode image-mode]#
----
=====

We then move the VM image file to file that's accessible by libvirt and import it.

[.lines_7]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
# qemu-img convert -f qcow2 -O qcow2 -o lazy_refcounts=on ./output/qcow2/disk.qcow2 /var/lib/libvirt/images/disk.qcow2
# virt-install --name vm --os-variant rhel-unknown --memory 2048 --vcpus 2 --nographics --import --disk /var/lib/libvirt/images/disk.qcow2
----

We can now log in and explore the system.

[#update-rollback]
== Actualización y rollback

`+bootc+` es el comando que maneja los contenedores dentro de la VM. Viene con un temporizador que regularmente activa un servicio de systemd.
Ese servicio, si detecta que una nueva imagen está disponible, la descarga y reinicia el sistema para aplicarla.

Después de hacer log-in en la máquina comprobamos que el temporizador está activo:

[.lines_7]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
# sudo systemctl status bootc-fetch-apply-updates.timer
----

En lo que sigue, vamos a crear una nueva imagen y subirla al registro. Eso hará que el sistema se autoactualice. Observaremos en una consola el estado del servicio:

[.lines_7]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
# sudo journalctl -f -u bootc-fetch-apply-updates
Oct 01 16:05:54 localhost.localdomain systemd[1]: Starting Apply bootc updates...
Oct 01 16:05:54 localhost.localdomain bootc[1179]: Fetching ostree-unverified-registry:<registry>/demo:latest
Oct 01 16:05:54 localhost.localdomain bootc[1179]: No changes in <registry>/demo:latest => sha256:40106b8d8e453901b78398c819a6b95f4d7b55a28b8783d8e19e276197f2f814
Oct 01 16:05:54 localhost.localdomain bootc[1179]: No update available.
Oct 01 16:05:54 localhost.localdomain systemd[1]: bootc-fetch-apply-updates.service: Deactivated successfully.
Oct 01 16:05:54 localhost.localdomain systemd[1]: Finished Apply bootc updates.
----

En otra consola, cambiamos la Containerfile

[.lines_7]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
FROM quay.io/centos-bootc/centos-bootc:stream9
COPY bootc-fetch-apply-updates.timer /lib/systemd/system/
RUN echo v2 > /version
----

identificando esta nueva version en el archivo `+/version+`.

Seguimos los mismos pasos como en <<crear-images>>.

Veremos, cómo el servicio `+bootc-fetch-apply-updates+` encuentra la actualización, descarga los datos y reinicia el sistema.

[.lines_7]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
Oct 01 16:07:29 localhost.localdomain systemd[1]: Starting Apply bootc updates...
Oct 01 16:07:29 localhost.localdomain bootc[1206]: Fetching ostree-unverified-registry:<registry>/demo:latest
Oct 01 16:07:30 localhost.localdomain bootc[1206]: layers already present: 70; layers needed: 1 (141 bytes)
Oct 01 16:07:30 localhost.localdomain bootc[1206]: layers already present: 70; layers needed: 1 (141 bytes)
----

Después del reinicio, hacemos login y comprobamos que efectivamente, el sistema ha sido actualizado.

[.lines_7]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
$ sudo cat /version
v2
----

`+bootc+` si encontramos problemas con esta actualización podemos revertirla sin problema. Manualmente lo conseguimos ejecutando

[.lines_7]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
$ sudo bootc rollback
----

El sistema reiniciará y veremos que nos encontramos en la versión previa:

[.lines_7]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
$ sudo cat /version
v1
----

Si queremos evitar que el sistema se auto-actualice de nuevo a la versión errónea, debemos deshabilitar el temporizador

[.lines_7]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
$ sudo systemctl disable --now bootc-fetch-apply-updates.timer
----

Como hemos visto, `+bootc+` integra bien con herramientas existentes de contenedores. Esto significa que también disponemos de https://github.com/fedora-iot/greenboot[greenboot]
para que revertir automáticamente un sistema que no inicie bien después de una actualización.
